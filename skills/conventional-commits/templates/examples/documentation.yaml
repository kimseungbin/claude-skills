# Example Commits: Documentation
# Real-world documentation commit examples

description: "Example commits for documentation changes"

# When LLM reads this file:
# - Looking for documentation commit patterns
# - Wants to see good documentation practices
# - Needs examples of doc scope usage

# Project documentation (docs(project))
project_docs_examples:
  claude_md_update:
    message: "docs(project): Update CLAUDE.md with new construct hierarchy"
    body: |
      Document ServiceInfraConstruct and ServiceAppConstruct split.

      Updated sections:
      - Architecture Overview diagram
      - /lib/constructs/ directory structure
      - Important Patterns section for two-phase deployment

      Skill: conventional-commits
    why_good: "Clear what was updated, synchronized with code changes"

  readme_improvement:
    message: "docs(project): Add troubleshooting section to README"
    body: |
      Add common issues and solutions for deployment problems.

      - CloudFormation stack update failures
      - ECS task startup issues
      - ALB health check failures

      Skill: conventional-commits
    why_good: "Helpful addition with specific topics"

  implementation_guide:
    message: "docs(project): Add QA environment setup guide"
    body: |
      Document complete setup process for QA environment.

      Covers:
      - AWS account preparation
      - CDK bootstrap
      - Configuration changes
      - GitHub Actions setup

      Skill: conventional-commits
    why_good: "Comprehensive guide for complex process"

# Feature documentation (docs(features))
feature_docs_examples:
  new_feature:
    message: "docs(features): Add Feature #18 for two-phase service deployment"
    body: |
      Document two-phase deployment pattern.

      - Problem statement and motivation
      - Proposed solution with diagrams
      - Implementation tasks (7 tasks)
      - Testing and rollback procedures

      Skill: conventional-commits
    why_good: "Complete feature specification"

  feature_status:
    message: "docs(features): Update Feature #12 implementation status"
    body: |
      Mark blue-green deployment as deferred.

      Current approach using ECS rolling deployment is sufficient.
      Blue-green adds complexity without significant benefit for current scale.

      Skill: conventional-commits
    why_good: "Status update with rationale"

# Backlog documentation (docs(backlog))
backlog_examples:
  add_task:
    message: "docs(backlog): Add TODO-23 for ECR lifecycle policies"
    body: |
      Add task to implement ECR image cleanup.

      - Automatic deletion of untagged images after 7 days
      - Keep last 10 tagged images
      - Estimated effort: 2 hours

      Skill: conventional-commits
    why_good: "Clear task description with scope"

  mark_completed:
    message: "docs(backlog): Mark TODO-06 as completed"
    body: |
      ECR naming standardization implemented and tested.

      Completed in commits:
      - feat(types): Add RepositoryName enum
      - refactor(service): Standardize ECR naming

      Skill: conventional-commits
    why_good: "References related commits"

# Refactoring task documentation (docs(refactoring))
refactoring_docs_examples:
  new_task:
    message: "docs(refactoring): Add ARCH-05 for Config Service injection"
    body: |
      Document config service dependency injection refactoring.

      Problem: ConfigService passed via CDK context (untyped)
      Solution: Pass via construct props (type-safe)

      Benefits:
      - Type safety at compile time
      - Explicit dependencies
      - Easier testing

      Skill: conventional-commits
    why_good: "Problem-solution format with benefits"

  update_status:
    message: "docs(refactoring): Update ARCH-04 with implementation notes"
    body: |
      Add lessons learned from resource naming implementation.

      - overrideLogicalId() usage patterns
      - Testing approach with cdk diff
      - Incremental rollout strategy

      Skill: conventional-commits
    why_good: "Captures implementation knowledge"

# Skill documentation (docs(skill))
skill_docs_examples:
  skill_update:
    message: "docs(skill): Add LLM reading scenarios to conventional-commits"
    body: |
      Document minimal-context loading pattern for skill files.

      - Three usage scenarios with context sizes
      - Decision tree for when to load detailed files
      - 50% context reduction compared to inline approach

      Skill: conventional-commits
    why_good: "Explains new pattern with metrics"

  skill_guide:
    message: "docs(skill): Document pre-push hook rationale in conventional-commits"
    body: |
      Add hooks/README.md explaining why infrastructure needs pre-push hooks.

      - Infrastructure constraints (can't test multiple branches)
      - Master-only development strategy
      - Why GitHub CI is insufficient

      Skill: conventional-commits
    why_good: "Explains strategic decision with context"

# Inline documentation (docs)
inline_docs_examples:
  typo_fix:
    message: "docs(service): Fix typo in TaskDefinition comment"
    body: |
      Correct 'taskDefnition' → 'taskDefinition' in comment.

      Skill: conventional-commits
    why_good: "Simple typo fix, acceptable as docs type"

  comment_clarification:
    message: "docs(config): Clarify ConfigService usage in comments"
    body: |
      Expand comment explaining configuration hierarchy.

      No code changes, only comment improvements.

      Skill: conventional-commits
    why_good: "Documentation improvement without code changes"

# Anti-patterns (what NOT to do)
antipatterns:
  mixed_code_and_docs:
    bad_message: "docs(service): Refactor ServiceConstruct and update comments"
    why_bad: "Mixes code refactoring with documentation"
    good_approach: |
      Split into two commits:
      1. refactor(service): Extract ServiceInfraConstruct
      2. docs(project): Update CLAUDE.md with new construct hierarchy

  adding_jsdoc:
    bad_message: "docs(service): Add JSDoc comments to functions"
    why_bad: "JSDoc comments are code changes, not pure documentation"
    good_message: "refactor(service): Add JSDoc documentation to constructs"

  vague_update:
    bad_message: "docs(project): Update documentation"
    why_bad: "Too vague, doesn't say what was updated"
    good_message: "docs(project): Add deployment troubleshooting guide"

# Pattern: Keeping documentation synchronized
sync_pattern:
  code_first_then_docs:
    workflow:
      - "1. Make code changes → commit as feat/fix/refactor"
      - "2. Update CLAUDE.md → commit as docs(project)"
      - "3. Update feature docs → commit as docs(features)"

    example_sequence:
      - commit_1:
          message: "feat(main): Add profile microservice"
          type: "Code commit"

      - commit_2:
          message: "docs(project): Update CLAUDE.md with profile service"
          type: "Documentation commit"

    why_separate: "Clear separation in git history, easier review"

  proactive_documentation:
    trigger: "Use maintaining-documentation skill after code changes"
    when: "Architecture changes, new constructs, configuration patterns"